% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/topologies.R
\name{computeElasticPrincipalCircle}
\alias{computeElasticPrincipalCircle}
\title{Conscruct a princial elastic circle}
\usage{
computeElasticPrincipalCircle(X, NumNodes, InitNodes = 3, NumEdges = Inf,
  Lambda = 0.01, Mu = 0.1, MaxNumberOfIterations = 10,
  TrimmingRadius = Inf, eps = 0.01, Do_PCA = TRUE,
  InitNodePositions = NULL, InitEdges = NULL, CenterData = TRUE,
  ComputeMSEP = TRUE, verbose = FALSE, ShowTimer = FALSE,
  ReduceDimension = NULL, drawAccuracyComplexity = TRUE,
  drawPCAView = TRUE, drawEnergy = TRUE, n.cores = 1, ClusType = "Sock",
  nReps = 1, Subsets = list(), ProbPoint = 1, Mode = 1,
  FastSolve = FALSE, AvoidSolitary = FALSE)
}
\arguments{
\item{X}{numerical 2D matrix, the n-by-m matrix with the position of n m-dimensional points}

\item{NumNodes}{integer, the number of nodes of the principal graph}

\item{InitNodes}{integer, number of points to include in the initial graph}

\item{NumEdges}{integer, the maximum nulber of edges}

\item{Lambda}{real, the lambda parameter used the compute the elastic energy}

\item{Mu}{real, the lambda parameter used the compute the elastic energy}

\item{MaxNumberOfIterations}{integer, maximum number of steps to embed the nodes in the data}

\item{TrimmingRadius}{real, maximal distance of point from a node to affect its embedment}

\item{eps}{real, minimal relative change in the position of the nodes to stop embedment}

\item{Do_PCA}{boolean, should data and initial node positions be PCA trnasformed?}

\item{InitNodePositions}{numerical 2D matrix, the k-by-m matrix with k m-dimensional positions of the nodes
in the initial step}

\item{InitEdges}{numerical 2D matrix, the e-by-2 matrix with e end-points of the edges connecting the nodes}

\item{CenterData}{boolean, should data and initial node positions be centered?}

\item{ComputeMSEP}{boolean, should MSEP be computed when building the report?}

\item{verbose}{boolean, should debugging information be reported?}

\item{ShowTimer}{boolean, should the time to construct the graph be computed and reported for each step?}

\item{ReduceDimension}{integer vector, vector of principal components to retain when performing
dimensionality reduction. If NULL all the components will be used}

\item{drawAccuracyComplexity}{boolean, should the accuracy VS complexity plot be reported?}

\item{drawPCAView}{boolean, should a 2D plot of the points and pricipal curve be dranw for the final configuration?}

\item{drawEnergy}{boolean, should changes of evergy VS the number of nodes be reported?}

\item{n.cores}{either an integer (indicating the number of cores to used for the creation of a cluster) or 
cluster structure returned, e.g., by makeCluster. If a cluster structure is used, all the nodes must contains X
(this is done using clusterExport)}

\item{ClusType}{string, the type of cluster to use. It can gbe either "Sock" or "Fork".
Currently fork clustering only works in Linux}

\item{nReps}{integer, number of replica of the construction}

\item{Subsets}{list of column names (or column number). When specified a principal tree will be computed for each of the subsets specified.}

\item{ProbPoint}{real between 0 and 1, probability of inclusing of a single point for each computation}

\item{Mode}{integer, the energy computation mode}

\item{FastSolve}{boolean, should FastSolve be used when fitting the points to the data?}

\item{AvoidSolitary}{}
}
\value{
A named list
}
\description{
This function is a wrapper to the computeElasticPrincipalGraph function that construct the appropriate initial graph and grammars
when constructing a circle
}
\examples{

Elastic circle with different parameters
PG <- computeElasticPrincipalCircle(X = circle_data, NumNodes = 30, InitNodes = 3, verbose = TRUE)
PG <- computeElasticPrincipalCircle(X = circle_data, NumNodes = 30, InitNodes = 3, verbose = TRUE, Mu = 1, Lambda = .001)

Bootstrapping the construction of the circle
PG <- computeElasticPrincipalCircle(X = circle_data, NumNodes = 40, InitNodes = 3,
drawAccuracyComplexity = FALSE, drawPCAView = FALSE, drawEnergy = FALSE,
verbose = FALSE, nReps = 50, ProbPoint = .8)

PlotPG(X = circle_data, TargetPG = PG[[length(PG)]], BootPG = PG[1:(length(PG)-1)])

}
